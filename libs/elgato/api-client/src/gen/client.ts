/**
 * Generated by orval v7.4.0 🍺
 * Do not edit manually.
 * Elgato API
 * OpenAPI spec version: 0.1
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { customAxiosInstance } from '../custom-axios'
export type GetHealthStatus503Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

/**
 * @nullable
 */
export type GetHealthStatus503Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type GetHealthStatus503Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type GetHealthStatus503 = {
  status?: string
  /** @nullable */
  info?: GetHealthStatus503Info
  /** @nullable */
  error?: GetHealthStatus503Error
  details?: GetHealthStatus503Details
}

export type GetHealthStatus200Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

/**
 * @nullable
 */
export type GetHealthStatus200Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type GetHealthStatus200Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type GetHealthStatus200 = {
  status?: string
  /** @nullable */
  info?: GetHealthStatus200Info
  /** @nullable */
  error?: GetHealthStatus200Error
  details?: GetHealthStatus200Details
}

export interface ActionResponseDto {
  on: boolean
  /** @nullable */
  hue?: number | null
  /** @nullable */
  saturation?: number | null
  /** @nullable */
  brightness?: number | null
  /** @nullable */
  temperature?: number | null
  powerOnly: boolean
  macAddress: string
  id: number
  commandId: number
}

export interface CommandResponseDto {
  name: string
  actions: ActionResponseDto[]
  id: number
  hash: string
}

export interface CommandsListResponseDto {
  commands: CommandResponseDto[]
}

export interface ActionRequestDto {
  on: boolean
  /** @nullable */
  hue?: number | null
  /** @nullable */
  saturation?: number | null
  /** @nullable */
  brightness?: number | null
  /** @nullable */
  temperature?: number | null
  powerOnly: boolean
  macAddress: string
}

export interface CommandRequestDto {
  name: string
  actions: ActionRequestDto[]
}

export interface LocationDataResponseDto {
  longitude: number
  latitude: number
  name: string
  sunrise: string
  sunset: string
  /** @nullable */
  firstLight: string | null
  /** @nullable */
  lastLight: string | null
  dawn: string
  dusk: string
  solarNoon: string
  goldenHour: string
  /** Time between sunrise and sunset in seconds. */
  dayLength: number
  timeZone: string
  utcOffset: number
}

export interface LocationResponseDto {
  longitude: number
  latitude: number
  name: string
}

export interface LocationUpdateRequestDto {
  longitude: number
  latitude: number
  name: string
}

export interface DeviceSettingsRequestDto {
  sunrise?: boolean
  sunset?: boolean
}

export interface DeviceSettingsResponseDto {
  sunrise: boolean
  sunset: boolean
}

export interface TransitionToColorRequestDto {
  hue: number
  saturation: number
  brightness: number
}

export interface DevicePowerStateRequestDto {
  on: boolean
  /** @nullable */
  hue?: number | null
  /** @nullable */
  saturation?: number | null
  /** @nullable */
  brightness?: number | null
  /** @nullable */
  temperature?: number | null
}

export interface DeviceDisplayNameRequestDto {
  displayName: string
}

export interface DeviceState {
  on: boolean
  /** @nullable */
  hue?: number | null
  /** @nullable */
  saturation?: number | null
  /** @nullable */
  brightness?: number | null
  /** @nullable */
  temperature?: number | null
}

export interface DeviceDetailsResponseDto {
  /** The unique id for the device is its mac address. */
  macAddress: string
  displayName: string
  details: ElgatoDeviceDetailsResponseDto
  state: DeviceState
  /** @nullable */
  lastSeen: string | null
}

export interface DeviceResponseDto {
  /** The unique id for the device is its mac address. */
  macAddress: string
  displayName: string
}

export interface DeviceListResponseDto {
  devices: DeviceResponseDto[]
}

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeviceType = {
  RingLight: 'RingLight',
  LightStrip: 'LightStrip',
  Unknown: 'Unknown',
} as const

export interface ElgatoDeviceDetailsResponseDto {
  productName: string
  deviceType: DeviceType
  displayName: string
}

export interface DiscoveredDeviceResponseDto {
  /** The mac address of the device. */
  id: string
  macAddress: string
  name: string
  fqdn: string
  host: string
  /** @nullable */
  ipv4?: string | null
  port: number
  displayName: string
  productName: string
  type: DeviceType
  isControlled: boolean
}

export interface DiscoveredDevicesResponseDto {
  devices: DiscoveredDeviceResponseDto[]
}

export const discoveredDevices = (signal?: AbortSignal) => {
  return customAxiosInstance<DiscoveredDevicesResponseDto>({ url: `/api/discovery/devices`, method: 'GET', signal })
}

export const getDiscoveredDevicesQueryKey = () => {
  return [`/api/discovery/devices`] as const
}

export const getDiscoveredDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof discoveredDevices>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getDiscoveredDevicesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof discoveredDevices>>> = ({ signal }) =>
    discoveredDevices(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type DiscoveredDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof discoveredDevices>>>
export type DiscoveredDevicesQueryError = unknown

export function useDiscoveredDevices<TData = Awaited<ReturnType<typeof discoveredDevices>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDiscoveredDevices<
  TData = Awaited<ReturnType<typeof discoveredDevices>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDiscoveredDevices<
  TData = Awaited<ReturnType<typeof discoveredDevices>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useDiscoveredDevices<
  TData = Awaited<ReturnType<typeof discoveredDevices>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getDiscoveredDevicesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const addDiscoveredDevice = (deviceId: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/discovery/add-by-id/${deviceId}`, method: 'POST', signal })
}

export const getAddDiscoveredDeviceMutationOptions = <
  TData = Awaited<ReturnType<typeof addDiscoveredDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { deviceId: string }, TContext>
}) => {
  const mutationKey = ['addDiscoveredDevice']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDiscoveredDevice>>, { deviceId: string }> = (
    props,
  ) => {
    const { deviceId } = props ?? {}

    return addDiscoveredDevice(deviceId)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { deviceId: string }, TContext>
}

export type AddDiscoveredDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof addDiscoveredDevice>>>

export type AddDiscoveredDeviceMutationError = unknown

export const useAddDiscoveredDevice = <
  TData = Awaited<ReturnType<typeof addDiscoveredDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { deviceId: string }, TContext>
}): UseMutationResult<TData, TError, { deviceId: string }, TContext> => {
  const mutationOptions = getAddDiscoveredDeviceMutationOptions(options)

  return useMutation(mutationOptions)
}

export const addManualDevice = (address: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/discovery/add-by-address/${address}`, method: 'POST', signal })
}

export const getAddManualDeviceMutationOptions = <
  TData = Awaited<ReturnType<typeof addManualDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { address: string }, TContext>
}) => {
  const mutationKey = ['addManualDevice']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addManualDevice>>, { address: string }> = (props) => {
    const { address } = props ?? {}

    return addManualDevice(address)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { address: string }, TContext>
}

export type AddManualDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof addManualDevice>>>

export type AddManualDeviceMutationError = unknown

export const useAddManualDevice = <
  TData = Awaited<ReturnType<typeof addManualDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { address: string }, TContext>
}): UseMutationResult<TData, TError, { address: string }, TContext> => {
  const mutationOptions = getAddManualDeviceMutationOptions(options)

  return useMutation(mutationOptions)
}

export const deviceList = (signal?: AbortSignal) => {
  return customAxiosInstance<DeviceListResponseDto>({ url: `/api/devices`, method: 'GET', signal })
}

export const getDeviceListQueryKey = () => {
  return [`/api/devices`] as const
}

export const getDeviceListQueryOptions = <TData = Awaited<ReturnType<typeof deviceList>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getDeviceListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof deviceList>>> = ({ signal }) => deviceList(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type DeviceListQueryResult = NonNullable<Awaited<ReturnType<typeof deviceList>>>
export type DeviceListQueryError = unknown

export function useDeviceList<TData = Awaited<ReturnType<typeof deviceList>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDeviceList<TData = Awaited<ReturnType<typeof deviceList>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDeviceList<TData = Awaited<ReturnType<typeof deviceList>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useDeviceList<TData = Awaited<ReturnType<typeof deviceList>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getDeviceListQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const deviceDetails = (macAddress: string, signal?: AbortSignal) => {
  return customAxiosInstance<DeviceDetailsResponseDto>({ url: `/api/devices/${macAddress}`, method: 'GET', signal })
}

export const getDeviceDetailsQueryKey = (macAddress: string) => {
  return [`/api/devices/${macAddress}`] as const
}

export const getDeviceDetailsQueryOptions = <TData = Awaited<ReturnType<typeof deviceDetails>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getDeviceDetailsQueryKey(macAddress)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof deviceDetails>>> = ({ signal }) =>
    deviceDetails(macAddress, signal)

  return { queryKey, queryFn, enabled: !!macAddress, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type DeviceDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof deviceDetails>>>
export type DeviceDetailsQueryError = unknown

export function useDeviceDetails<TData = Awaited<ReturnType<typeof deviceDetails>>, TError = unknown>(
  macAddress: string,
  options: {
    query: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDeviceDetails<TData = Awaited<ReturnType<typeof deviceDetails>>, TError = unknown>(
  macAddress: string,
  options?: {
    query?: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDeviceDetails<TData = Awaited<ReturnType<typeof deviceDetails>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useDeviceDetails<TData = Awaited<ReturnType<typeof deviceDetails>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getDeviceDetailsQueryOptions(macAddress, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const setDisplayName = (macAddress: string, deviceDisplayNameRequestDto: DeviceDisplayNameRequestDto) => {
  return customAxiosInstance<void>({
    url: `/api/devices/${macAddress}/display-name`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: deviceDisplayNameRequestDto,
  })
}

export const getSetDisplayNameMutationOptions = <
  TData = Awaited<ReturnType<typeof setDisplayName>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DeviceDisplayNameRequestDto }, TContext>
}) => {
  const mutationKey = ['setDisplayName']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setDisplayName>>,
    { macAddress: string; data: DeviceDisplayNameRequestDto }
  > = (props) => {
    const { macAddress, data } = props ?? {}

    return setDisplayName(macAddress, data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { macAddress: string; data: DeviceDisplayNameRequestDto },
    TContext
  >
}

export type SetDisplayNameMutationResult = NonNullable<Awaited<ReturnType<typeof setDisplayName>>>
export type SetDisplayNameMutationBody = DeviceDisplayNameRequestDto
export type SetDisplayNameMutationError = unknown

export const useSetDisplayName = <
  TData = Awaited<ReturnType<typeof setDisplayName>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DeviceDisplayNameRequestDto }, TContext>
}): UseMutationResult<TData, TError, { macAddress: string; data: DeviceDisplayNameRequestDto }, TContext> => {
  const mutationOptions = getSetDisplayNameMutationOptions(options)

  return useMutation(mutationOptions)
}

export const toggleDevice = (macAddress: string) => {
  return customAxiosInstance<void>({ url: `/api/devices/${macAddress}/toggle`, method: 'PUT' })
}

export const getToggleDeviceMutationOptions = <
  TData = Awaited<ReturnType<typeof toggleDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string }, TContext>
}) => {
  const mutationKey = ['toggleDevice']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleDevice>>, { macAddress: string }> = (props) => {
    const { macAddress } = props ?? {}

    return toggleDevice(macAddress)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { macAddress: string }, TContext>
}

export type ToggleDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof toggleDevice>>>

export type ToggleDeviceMutationError = unknown

export const useToggleDevice = <
  TData = Awaited<ReturnType<typeof toggleDevice>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string }, TContext>
}): UseMutationResult<TData, TError, { macAddress: string }, TContext> => {
  const mutationOptions = getToggleDeviceMutationOptions(options)

  return useMutation(mutationOptions)
}

export const deviceSetPowerState = (macAddress: string, devicePowerStateRequestDto: DevicePowerStateRequestDto) => {
  return customAxiosInstance<void>({
    url: `/api/devices/${macAddress}/power-state`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: devicePowerStateRequestDto,
  })
}

export const getDeviceSetPowerStateMutationOptions = <
  TData = Awaited<ReturnType<typeof deviceSetPowerState>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DevicePowerStateRequestDto }, TContext>
}) => {
  const mutationKey = ['deviceSetPowerState']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceSetPowerState>>,
    { macAddress: string; data: DevicePowerStateRequestDto }
  > = (props) => {
    const { macAddress, data } = props ?? {}

    return deviceSetPowerState(macAddress, data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { macAddress: string; data: DevicePowerStateRequestDto },
    TContext
  >
}

export type DeviceSetPowerStateMutationResult = NonNullable<Awaited<ReturnType<typeof deviceSetPowerState>>>
export type DeviceSetPowerStateMutationBody = DevicePowerStateRequestDto
export type DeviceSetPowerStateMutationError = unknown

export const useDeviceSetPowerState = <
  TData = Awaited<ReturnType<typeof deviceSetPowerState>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DevicePowerStateRequestDto }, TContext>
}): UseMutationResult<TData, TError, { macAddress: string; data: DevicePowerStateRequestDto }, TContext> => {
  const mutationOptions = getDeviceSetPowerStateMutationOptions(options)

  return useMutation(mutationOptions)
}

export const transitionToColor = (macAddress: string, transitionToColorRequestDto: TransitionToColorRequestDto) => {
  return customAxiosInstance<void>({
    url: `/api/devices/${macAddress}/transition-to-color`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: transitionToColorRequestDto,
  })
}

export const getTransitionToColorMutationOptions = <
  TData = Awaited<ReturnType<typeof transitionToColor>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: TransitionToColorRequestDto }, TContext>
}) => {
  const mutationKey = ['transitionToColor']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transitionToColor>>,
    { macAddress: string; data: TransitionToColorRequestDto }
  > = (props) => {
    const { macAddress, data } = props ?? {}

    return transitionToColor(macAddress, data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { macAddress: string; data: TransitionToColorRequestDto },
    TContext
  >
}

export type TransitionToColorMutationResult = NonNullable<Awaited<ReturnType<typeof transitionToColor>>>
export type TransitionToColorMutationBody = TransitionToColorRequestDto
export type TransitionToColorMutationError = unknown

export const useTransitionToColor = <
  TData = Awaited<ReturnType<typeof transitionToColor>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: TransitionToColorRequestDto }, TContext>
}): UseMutationResult<TData, TError, { macAddress: string; data: TransitionToColorRequestDto }, TContext> => {
  const mutationOptions = getTransitionToColorMutationOptions(options)

  return useMutation(mutationOptions)
}

export const currentDeviceSettings = (macAddress: string, signal?: AbortSignal) => {
  return customAxiosInstance<DeviceSettingsResponseDto>({
    url: `/api/devices/${macAddress}/settings`,
    method: 'GET',
    signal,
  })
}

export const getCurrentDeviceSettingsQueryKey = (macAddress: string) => {
  return [`/api/devices/${macAddress}/settings`] as const
}

export const getCurrentDeviceSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof currentDeviceSettings>>,
  TError = unknown,
>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCurrentDeviceSettingsQueryKey(macAddress)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentDeviceSettings>>> = ({ signal }) =>
    currentDeviceSettings(macAddress, signal)

  return { queryKey, queryFn, enabled: !!macAddress, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type CurrentDeviceSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof currentDeviceSettings>>>
export type CurrentDeviceSettingsQueryError = unknown

export function useCurrentDeviceSettings<TData = Awaited<ReturnType<typeof currentDeviceSettings>>, TError = unknown>(
  macAddress: string,
  options: {
    query: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCurrentDeviceSettings<TData = Awaited<ReturnType<typeof currentDeviceSettings>>, TError = unknown>(
  macAddress: string,
  options?: {
    query?: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCurrentDeviceSettings<TData = Awaited<ReturnType<typeof currentDeviceSettings>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCurrentDeviceSettings<TData = Awaited<ReturnType<typeof currentDeviceSettings>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCurrentDeviceSettingsQueryOptions(macAddress, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const updateDeviceSettings = (macAddress: string, deviceSettingsRequestDto: DeviceSettingsRequestDto) => {
  return customAxiosInstance<DeviceSettingsResponseDto>({
    url: `/api/devices/${macAddress}/settings`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: deviceSettingsRequestDto,
  })
}

export const getUpdateDeviceSettingsMutationOptions = <
  TData = Awaited<ReturnType<typeof updateDeviceSettings>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DeviceSettingsRequestDto }, TContext>
}) => {
  const mutationKey = ['updateDeviceSettings']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeviceSettings>>,
    { macAddress: string; data: DeviceSettingsRequestDto }
  > = (props) => {
    const { macAddress, data } = props ?? {}

    return updateDeviceSettings(macAddress, data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { macAddress: string; data: DeviceSettingsRequestDto },
    TContext
  >
}

export type UpdateDeviceSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeviceSettings>>>
export type UpdateDeviceSettingsMutationBody = DeviceSettingsRequestDto
export type UpdateDeviceSettingsMutationError = unknown

export const useUpdateDeviceSettings = <
  TData = Awaited<ReturnType<typeof updateDeviceSettings>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { macAddress: string; data: DeviceSettingsRequestDto }, TContext>
}): UseMutationResult<TData, TError, { macAddress: string; data: DeviceSettingsRequestDto }, TContext> => {
  const mutationOptions = getUpdateDeviceSettingsMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getHealthStatus = (signal?: AbortSignal) => {
  return customAxiosInstance<GetHealthStatus200>({ url: `/api/health`, method: 'GET', signal })
}

export const getGetHealthStatusQueryKey = () => {
  return [`/api/health`] as const
}

export const getGetHealthStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHealthStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthStatus>>> = ({ signal }) => getHealthStatus(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type GetHealthStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getHealthStatus>>>
export type GetHealthStatusQueryError = GetHealthStatus503

export function useGetHealthStatus<
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetHealthStatus<
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetHealthStatus<
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetHealthStatus<
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHealthStatusQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const updateLocation = (locationUpdateRequestDto: LocationUpdateRequestDto, signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/location`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: locationUpdateRequestDto,
    signal,
  })
}

export const getUpdateLocationMutationOptions = <
  TData = Awaited<ReturnType<typeof updateLocation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LocationUpdateRequestDto }, TContext>
}) => {
  const mutationKey = ['updateLocation']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateLocation>>, { data: LocationUpdateRequestDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return updateLocation(data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LocationUpdateRequestDto },
    TContext
  >
}

export type UpdateLocationMutationResult = NonNullable<Awaited<ReturnType<typeof updateLocation>>>
export type UpdateLocationMutationBody = LocationUpdateRequestDto
export type UpdateLocationMutationError = unknown

export const useUpdateLocation = <
  TData = Awaited<ReturnType<typeof updateLocation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LocationUpdateRequestDto }, TContext>
}): UseMutationResult<TData, TError, { data: LocationUpdateRequestDto }, TContext> => {
  const mutationOptions = getUpdateLocationMutationOptions(options)

  return useMutation(mutationOptions)
}

export const currentLocation = (signal?: AbortSignal) => {
  return customAxiosInstance<LocationResponseDto>({ url: `/api/location`, method: 'GET', signal })
}

export const getCurrentLocationQueryKey = () => {
  return [`/api/location`] as const
}

export const getCurrentLocationQueryOptions = <
  TData = Awaited<ReturnType<typeof currentLocation>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCurrentLocationQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentLocation>>> = ({ signal }) => currentLocation(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type CurrentLocationQueryResult = NonNullable<Awaited<ReturnType<typeof currentLocation>>>
export type CurrentLocationQueryError = unknown

export function useCurrentLocation<TData = Awaited<ReturnType<typeof currentLocation>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCurrentLocation<TData = Awaited<ReturnType<typeof currentLocation>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCurrentLocation<TData = Awaited<ReturnType<typeof currentLocation>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useCurrentLocation<TData = Awaited<ReturnType<typeof currentLocation>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCurrentLocationQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getLocationData = (signal?: AbortSignal) => {
  return customAxiosInstance<LocationDataResponseDto>({ url: `/api/location/location-data`, method: 'GET', signal })
}

export const getGetLocationDataQueryKey = () => {
  return [`/api/location/location-data`] as const
}

export const getGetLocationDataQueryOptions = <
  TData = Awaited<ReturnType<typeof getLocationData>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetLocationDataQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationData>>> = ({ signal }) => getLocationData(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type GetLocationDataQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationData>>>
export type GetLocationDataQueryError = unknown

export function useGetLocationData<TData = Awaited<ReturnType<typeof getLocationData>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetLocationData<TData = Awaited<ReturnType<typeof getLocationData>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetLocationData<TData = Awaited<ReturnType<typeof getLocationData>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetLocationData<TData = Awaited<ReturnType<typeof getLocationData>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLocationDataQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Trigger a predefined command via apple shortcuts.
 */
export const triggerAppleShortcutsCommand = (hash: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/public/apple-shortcuts/${hash}`, method: 'POST', signal })
}

export const getTriggerAppleShortcutsCommandMutationOptions = <
  TData = Awaited<ReturnType<typeof triggerAppleShortcutsCommand>>,
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { hash: string }, TContext>
}) => {
  const mutationKey = ['triggerAppleShortcutsCommand']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof triggerAppleShortcutsCommand>>, { hash: string }> = (
    props,
  ) => {
    const { hash } = props ?? {}

    return triggerAppleShortcutsCommand(hash)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { hash: string }, TContext>
}

export type TriggerAppleShortcutsCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerAppleShortcutsCommand>>
>

export type TriggerAppleShortcutsCommandMutationError = void

/**
 * @summary Trigger a predefined command via apple shortcuts.
 */
export const useTriggerAppleShortcutsCommand = <
  TData = Awaited<ReturnType<typeof triggerAppleShortcutsCommand>>,
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { hash: string }, TContext>
}): UseMutationResult<TData, TError, { hash: string }, TContext> => {
  const mutationOptions = getTriggerAppleShortcutsCommandMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Toggles devices on and off.
 */
export const toggleDevicePowerState = (macAddress: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/public/stream-deck/toggle/${macAddress}`, method: 'GET', signal })
}

export const getToggleDevicePowerStateQueryKey = (macAddress: string) => {
  return [`/api/public/stream-deck/toggle/${macAddress}`] as const
}

export const getToggleDevicePowerStateQueryOptions = <
  TData = Awaited<ReturnType<typeof toggleDevicePowerState>>,
  TError = unknown,
>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getToggleDevicePowerStateQueryKey(macAddress)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof toggleDevicePowerState>>> = ({ signal }) =>
    toggleDevicePowerState(macAddress, signal)

  return { queryKey, queryFn, enabled: !!macAddress, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type ToggleDevicePowerStateQueryResult = NonNullable<Awaited<ReturnType<typeof toggleDevicePowerState>>>
export type ToggleDevicePowerStateQueryError = unknown

export function useToggleDevicePowerState<TData = Awaited<ReturnType<typeof toggleDevicePowerState>>, TError = unknown>(
  macAddress: string,
  options: {
    query: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useToggleDevicePowerState<TData = Awaited<ReturnType<typeof toggleDevicePowerState>>, TError = unknown>(
  macAddress: string,
  options?: {
    query?: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useToggleDevicePowerState<TData = Awaited<ReturnType<typeof toggleDevicePowerState>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Toggles devices on and off.
 */

export function useToggleDevicePowerState<TData = Awaited<ReturnType<typeof toggleDevicePowerState>>, TError = unknown>(
  macAddress: string,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getToggleDevicePowerStateQueryOptions(macAddress, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const createCommand = (commandRequestDto: CommandRequestDto, signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/commands`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: commandRequestDto,
    signal,
  })
}

export const getCreateCommandMutationOptions = <
  TData = Awaited<ReturnType<typeof createCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommandRequestDto }, TContext>
}) => {
  const mutationKey = ['createCommand']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCommand>>, { data: CommandRequestDto }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createCommand(data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: CommandRequestDto }, TContext>
}

export type CreateCommandMutationResult = NonNullable<Awaited<ReturnType<typeof createCommand>>>
export type CreateCommandMutationBody = CommandRequestDto
export type CreateCommandMutationError = unknown

export const useCreateCommand = <
  TData = Awaited<ReturnType<typeof createCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommandRequestDto }, TContext>
}): UseMutationResult<TData, TError, { data: CommandRequestDto }, TContext> => {
  const mutationOptions = getCreateCommandMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getCommands = (signal?: AbortSignal) => {
  return customAxiosInstance<CommandsListResponseDto>({ url: `/api/commands`, method: 'GET', signal })
}

export const getGetCommandsQueryKey = () => {
  return [`/api/commands`] as const
}

export const getGetCommandsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCommands>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCommandsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommands>>> = ({ signal }) => getCommands(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type GetCommandsQueryResult = NonNullable<Awaited<ReturnType<typeof getCommands>>>
export type GetCommandsQueryError = unknown

export function useGetCommands<TData = Awaited<ReturnType<typeof getCommands>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommands<TData = Awaited<ReturnType<typeof getCommands>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>> &
    Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommands<TData = Awaited<ReturnType<typeof getCommands>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCommands<TData = Awaited<ReturnType<typeof getCommands>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<TData, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCommandsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getCommand = (commandId: number, signal?: AbortSignal) => {
  return customAxiosInstance<CommandResponseDto>({ url: `/api/commands/${commandId}`, method: 'GET', signal })
}

export const getGetCommandQueryKey = (commandId: number) => {
  return [`/api/commands/${commandId}`] as const
}

export const getGetCommandQueryOptions = <TData = Awaited<ReturnType<typeof getCommand>>, TError = unknown>(
  commandId: number,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCommandQueryKey(commandId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommand>>> = ({ signal }) => getCommand(commandId, signal)

  return { queryKey, queryFn, enabled: !!commandId, ...queryOptions } as UseQueryOptions<TData, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>
  }
}

export type GetCommandQueryResult = NonNullable<Awaited<ReturnType<typeof getCommand>>>
export type GetCommandQueryError = unknown

export function useGetCommand<TData = Awaited<ReturnType<typeof getCommand>>, TError = unknown>(
  commandId: number,
  options: {
    query: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<DefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommand<TData = Awaited<ReturnType<typeof getCommand>>, TError = unknown>(
  commandId: number,
  options?: {
    query?: Partial<UseQueryOptions<TData, TError, TData>> &
      Pick<UndefinedInitialDataOptions<TData, TError, TData>, 'initialData'>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommand<TData = Awaited<ReturnType<typeof getCommand>>, TError = unknown>(
  commandId: number,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCommand<TData = Awaited<ReturnType<typeof getCommand>>, TError = unknown>(
  commandId: number,
  options?: { query?: Partial<UseQueryOptions<TData, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCommandQueryOptions(commandId, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

export const updateCommand = (commandId: number, commandRequestDto: CommandRequestDto) => {
  return customAxiosInstance<void>({
    url: `/api/commands/${commandId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: commandRequestDto,
  })
}

export const getUpdateCommandMutationOptions = <
  TData = Awaited<ReturnType<typeof updateCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { commandId: number; data: CommandRequestDto }, TContext>
}) => {
  const mutationKey = ['updateCommand']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCommand>>,
    { commandId: number; data: CommandRequestDto }
  > = (props) => {
    const { commandId, data } = props ?? {}

    return updateCommand(commandId, data)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { commandId: number; data: CommandRequestDto },
    TContext
  >
}

export type UpdateCommandMutationResult = NonNullable<Awaited<ReturnType<typeof updateCommand>>>
export type UpdateCommandMutationBody = CommandRequestDto
export type UpdateCommandMutationError = unknown

export const useUpdateCommand = <
  TData = Awaited<ReturnType<typeof updateCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { commandId: number; data: CommandRequestDto }, TContext>
}): UseMutationResult<TData, TError, { commandId: number; data: CommandRequestDto }, TContext> => {
  const mutationOptions = getUpdateCommandMutationOptions(options)

  return useMutation(mutationOptions)
}

export const deleteCommand = (commandId: number) => {
  return customAxiosInstance<void>({ url: `/api/commands/${commandId}`, method: 'DELETE' })
}

export const getDeleteCommandMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { commandId: number }, TContext>
}) => {
  const mutationKey = ['deleteCommand']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCommand>>, { commandId: number }> = (props) => {
    const { commandId } = props ?? {}

    return deleteCommand(commandId)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { commandId: number }, TContext>
}

export type DeleteCommandMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCommand>>>

export type DeleteCommandMutationError = unknown

export const useDeleteCommand = <
  TData = Awaited<ReturnType<typeof deleteCommand>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { commandId: number }, TContext>
}): UseMutationResult<TData, TError, { commandId: number }, TContext> => {
  const mutationOptions = getDeleteCommandMutationOptions(options)

  return useMutation(mutationOptions)
}
