/**
 * Generated by orval v7.18.0 ðŸº
 * Do not edit manually.
 * Feeds API
 * OpenAPI spec version: 0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customAxiosInstance } from '../custom-axios'
export interface AdminStatsResponseDto {
  feedCount: number
  articleCount: number
  userCount: number
}

export interface ArticleToggleUnreadDto {
  unread: boolean
}

export interface ArticleDto {
  /** @nullable */
  content: string | null
  date: string
  guid: string
  id: string
  feedId: string
  /** @nullable */
  link: string | null
  /** @nullable */
  title: string | null
}

export interface ArticleResponseDto {
  article: ArticleDto
  cursor: number
  starred: boolean
  unread: boolean
}

export interface StarArticleDto {
  starred: boolean
}

export enum Sort {
  desc = 'desc',
  asc = 'asc',
}
export interface PaginatedArticleResponseDto {
  content: ArticleResponseDto[]
  pageSize: number
  totalCount: number
  unreadCount: number
  lastCursor?: number
}

export interface UserLoginDto {
  username: string
  password: string
}

export interface LoginResponseDto {
  access_token: string
  refresh_token: string
}

export interface UserRegistrationDto {
  username: string
  password: string
}

export interface UserResponseDto {
  /** @nullable */
  email?: string | null
  id: string
  isAdmin: boolean
  username: string
}

export interface BootInfoDto {
  /** @pattern ^\d\.\d+$ */
  appVersion: string
  pageSize: number
}

export interface FeedInputDto {
  url?: string
  title: string
  feedUrl: string
}

export interface FeedResponseDto {
  feedUrl: string
  id: string
  originalTitle: string
  title?: string
}

export interface TagResponseDto {
  id: string
  name: string
  userId: string
}

export interface UserFeedResponseDto {
  feedUrl: string
  id: string
  feedId: string
  userId: string
  originalTitle: string
  title?: string
  includeRead: boolean
  disabled: boolean
  order: Sort
  expandContent: boolean
  unreadCount: number
  tags: TagResponseDto[]
}

export interface DiscoverResponseDto {
  /** @nullable */
  feedUrl: string | null
  /** @nullable */
  title: string | null
  url: string
}

export interface FeedSettingsResponseDto {
  id: string
  title: string
  expandContent: boolean
  includeRead: boolean
  disabled: boolean
  order: Sort
}

export interface UpdateFeedSettingsInputDto {
  expandContent: boolean
  includeRead: boolean
  disabled: boolean
  order: Sort
  title?: string
}

export interface TagFeedInputDto {
  tagId: string
}

export interface TagInputDto {
  name: string
}

export type MarkArticlesReadParams = {
  /**
   * The string that the article should match.
   */
  s?: string
  /**
   * The id of the feed where all articles should be marked as read.
   */
  f?: string
}

export type FindArticlesParams = {
  /**
   * The string that the article should match.
   */
  s?: string
  /**
   * Should read articles be included.
   */
  r?: boolean
  /**
   * Should articles appear in chronically ascending or descending order.
   */
  starred?: boolean
  /**
   * Should articles appear in chronically ascending or descending order.
   */
  sort?: Sort
  /**
   * The id of the feed this query should be limited to.
   */
  f?: string
  /**
   * Cursor of the last article for pagination.
   */
  cursor?: number
}

export type DiscoverFeedParams = {
  /**
   * URL of the website where a feed should be discovered.
   */
  url: string
}

/**
 * @nullable
 */
export type GetHealthStatus200Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type GetHealthStatus200Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type GetHealthStatus200Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type GetHealthStatus200 = {
  status?: string
  /** @nullable */
  info?: GetHealthStatus200Info
  /** @nullable */
  error?: GetHealthStatus200Error
  details?: GetHealthStatus200Details
}

/**
 * @nullable
 */
export type GetHealthStatus503Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type GetHealthStatus503Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type GetHealthStatus503Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type GetHealthStatus503 = {
  status?: string
  /** @nullable */
  info?: GetHealthStatus503Info
  /** @nullable */
  error?: GetHealthStatus503Error
  details?: GetHealthStatus503Details
}

export const getAdminStats = (signal?: AbortSignal) => {
  return customAxiosInstance<AdminStatsResponseDto>({ url: `/api/admin/stats`, method: 'GET', signal })
}

export const getGetAdminStatsInfiniteQueryKey = () => {
  return ['infinite', `/api/admin/stats`] as const
}

export const getGetAdminStatsQueryKey = () => {
  return [`/api/admin/stats`] as const
}

export const getGetAdminStatsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAdminStats>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAdminStatsInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminStats>>> = ({ signal }) => getAdminStats(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAdminStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdminStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminStats>>>
export type GetAdminStatsInfiniteQueryError = unknown

export function useGetAdminStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAdminStats>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminStats>>,
          TError,
          Awaited<ReturnType<typeof getAdminStats>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAdminStats>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminStats>>,
          TError,
          Awaited<ReturnType<typeof getAdminStats>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAdminStats>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAdminStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAdminStats>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAdminStatsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAdminStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminStats>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAdminStatsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminStats>>> = ({ signal }) => getAdminStats(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdminStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdminStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminStats>>>
export type GetAdminStatsQueryError = unknown

export function useGetAdminStats<TData = Awaited<ReturnType<typeof getAdminStats>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminStats>>,
          TError,
          Awaited<ReturnType<typeof getAdminStats>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminStats<TData = Awaited<ReturnType<typeof getAdminStats>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminStats>>,
          TError,
          Awaited<ReturnType<typeof getAdminStats>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminStats<TData = Awaited<ReturnType<typeof getAdminStats>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAdminStats<TData = Awaited<ReturnType<typeof getAdminStats>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminStats>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAdminStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const markArticlesRead = (params?: MarkArticlesReadParams, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/article/mark-articles-read`, method: 'POST', params, signal })
}

export const getMarkArticlesReadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markArticlesRead>>,
    TError,
    { params?: MarkArticlesReadParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof markArticlesRead>>,
  TError,
  { params?: MarkArticlesReadParams },
  TContext
> => {
  const mutationKey = ['markArticlesRead']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markArticlesRead>>,
    { params?: MarkArticlesReadParams }
  > = (props) => {
    const { params } = props ?? {}

    return markArticlesRead(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkArticlesReadMutationResult = NonNullable<Awaited<ReturnType<typeof markArticlesRead>>>

export type MarkArticlesReadMutationError = unknown

export const useMarkArticlesRead = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markArticlesRead>>,
      TError,
      { params?: MarkArticlesReadParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof markArticlesRead>>,
  TError,
  { params?: MarkArticlesReadParams },
  TContext
> => {
  const mutationOptions = getMarkArticlesReadMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const toggleUnread = (
  articleId: string,
  articleToggleUnreadDto: ArticleToggleUnreadDto,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<ArticleResponseDto>({
    url: `/api/article/${articleId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: articleToggleUnreadDto,
    signal,
  })
}

export const getToggleUnreadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toggleUnread>>,
    TError,
    { articleId: string; data: ArticleToggleUnreadDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof toggleUnread>>,
  TError,
  { articleId: string; data: ArticleToggleUnreadDto },
  TContext
> => {
  const mutationKey = ['toggleUnread']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toggleUnread>>,
    { articleId: string; data: ArticleToggleUnreadDto }
  > = (props) => {
    const { articleId, data } = props ?? {}

    return toggleUnread(articleId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type ToggleUnreadMutationResult = NonNullable<Awaited<ReturnType<typeof toggleUnread>>>
export type ToggleUnreadMutationBody = ArticleToggleUnreadDto
export type ToggleUnreadMutationError = unknown

export const useToggleUnread = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toggleUnread>>,
      TError,
      { articleId: string; data: ArticleToggleUnreadDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toggleUnread>>,
  TError,
  { articleId: string; data: ArticleToggleUnreadDto },
  TContext
> => {
  const mutationOptions = getToggleUnreadMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const starArticle = (articleId: string, starArticleDto: StarArticleDto) => {
  return customAxiosInstance<void>({
    url: `/api/article/${articleId}/star`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: starArticleDto,
  })
}

export const getStarArticleMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof starArticle>>,
    TError,
    { articleId: string; data: StarArticleDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof starArticle>>,
  TError,
  { articleId: string; data: StarArticleDto },
  TContext
> => {
  const mutationKey = ['starArticle']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof starArticle>>,
    { articleId: string; data: StarArticleDto }
  > = (props) => {
    const { articleId, data } = props ?? {}

    return starArticle(articleId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type StarArticleMutationResult = NonNullable<Awaited<ReturnType<typeof starArticle>>>
export type StarArticleMutationBody = StarArticleDto
export type StarArticleMutationError = unknown

export const useStarArticle = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof starArticle>>,
      TError,
      { articleId: string; data: StarArticleDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof starArticle>>,
  TError,
  { articleId: string; data: StarArticleDto },
  TContext
> => {
  const mutationOptions = getStarArticleMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const findArticles = (params?: FindArticlesParams, signal?: AbortSignal) => {
  return customAxiosInstance<PaginatedArticleResponseDto>({ url: `/api/article/find`, method: 'GET', params, signal })
}

export const getFindArticlesInfiniteQueryKey = (params?: FindArticlesParams) => {
  return ['infinite', `/api/article/find`, ...(params ? [params] : [])] as const
}

export const getFindArticlesQueryKey = (params?: FindArticlesParams) => {
  return [`/api/article/find`, ...(params ? [params] : [])] as const
}

export const getFindArticlesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        QueryKey,
        FindArticlesParams['cursor']
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindArticlesInfiniteQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticles>>, QueryKey, FindArticlesParams['cursor']> = ({
    signal,
    pageParam,
  }) => findArticles({ ...params, cursor: pageParam || params?.['cursor'] }, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findArticles>>,
    TError,
    TData,
    QueryKey,
    FindArticlesParams['cursor']
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindArticlesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findArticles>>>
export type FindArticlesInfiniteQueryError = unknown

export function useFindArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params: undefined | FindArticlesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        QueryKey,
        FindArticlesParams['cursor']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticles>>,
          TError,
          Awaited<ReturnType<typeof findArticles>>,
          QueryKey
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        QueryKey,
        FindArticlesParams['cursor']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticles>>,
          TError,
          Awaited<ReturnType<typeof findArticles>>,
          QueryKey
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        QueryKey,
        FindArticlesParams['cursor']
      >
    >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        QueryKey,
        FindArticlesParams['cursor']
      >
    >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindArticlesInfiniteQueryOptions(params, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindArticlesQueryOptions = <TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindArticlesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticles>>> = ({ signal }) => findArticles(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof findArticles>>>
export type FindArticlesQueryError = unknown

export function useFindArticles<TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params: undefined | FindArticlesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticles>>,
          TError,
          Awaited<ReturnType<typeof findArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindArticles<TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticles>>,
          TError,
          Awaited<ReturnType<typeof findArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindArticles<TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFindArticles<TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindArticlesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const recentlyReadArticles = (signal?: AbortSignal) => {
  return customAxiosInstance<ArticleResponseDto[]>({ url: `/api/article/recentlyRead`, method: 'GET', signal })
}

export const getRecentlyReadArticlesInfiniteQueryKey = () => {
  return ['infinite', `/api/article/recentlyRead`] as const
}

export const getRecentlyReadArticlesQueryKey = () => {
  return [`/api/article/recentlyRead`] as const
}

export const getRecentlyReadArticlesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRecentlyReadArticlesInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof recentlyReadArticles>>> = ({ signal }) =>
    recentlyReadArticles(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof recentlyReadArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecentlyReadArticlesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof recentlyReadArticles>>>
export type RecentlyReadArticlesInfiniteQueryError = unknown

export function useRecentlyReadArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recentlyReadArticles>>,
          TError,
          Awaited<ReturnType<typeof recentlyReadArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecentlyReadArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recentlyReadArticles>>,
          TError,
          Awaited<ReturnType<typeof recentlyReadArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecentlyReadArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecentlyReadArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRecentlyReadArticlesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getRecentlyReadArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof recentlyReadArticles>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRecentlyReadArticlesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof recentlyReadArticles>>> = ({ signal }) =>
    recentlyReadArticles(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof recentlyReadArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecentlyReadArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof recentlyReadArticles>>>
export type RecentlyReadArticlesQueryError = unknown

export function useRecentlyReadArticles<TData = Awaited<ReturnType<typeof recentlyReadArticles>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recentlyReadArticles>>,
          TError,
          Awaited<ReturnType<typeof recentlyReadArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecentlyReadArticles<TData = Awaited<ReturnType<typeof recentlyReadArticles>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recentlyReadArticles>>,
          TError,
          Awaited<ReturnType<typeof recentlyReadArticles>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecentlyReadArticles<TData = Awaited<ReturnType<typeof recentlyReadArticles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecentlyReadArticles<TData = Awaited<ReturnType<typeof recentlyReadArticles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRecentlyReadArticlesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const login = (userLoginDto: UserLoginDto, signal?: AbortSignal) => {
  return customAxiosInstance<LoginResponseDto>({
    url: `/api/authentication/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userLoginDto,
    signal,
  })
}

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext> => {
  const mutationKey = ['login']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: UserLoginDto }> = (props) => {
    const { data } = props ?? {}

    return login(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = UserLoginDto
export type LoginMutationError = unknown

export const useLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext> => {
  const mutationOptions = getLoginMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const logout = (signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/authentication/logout`, method: 'GET', signal })
}

export const getLogoutInfiniteQueryKey = () => {
  return ['infinite', `/api/authentication/logout`] as const
}

export const getLogoutQueryKey = () => {
  return [`/api/authentication/logout`] as const
}

export const getLogoutInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logout>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LogoutInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutInfiniteQueryError = unknown

export function useLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof logout>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof logout>>, TError, Awaited<ReturnType<typeof logout>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof logout>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof logout>>, TError, Awaited<ReturnType<typeof logout>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof logout>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof logout>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLogoutInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getLogoutQueryOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = unknown

export function useLogout<TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof logout>>, TError, Awaited<ReturnType<typeof logout>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLogout<TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof logout>>, TError, Awaited<ReturnType<typeof logout>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLogout<TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLogout<TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLogoutQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const register = (userRegistrationDto: UserRegistrationDto, signal?: AbortSignal) => {
  return customAxiosInstance<UserResponseDto>({
    url: `/api/authentication/register`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userRegistrationDto,
    signal,
  })
}

export const getRegisterMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext> => {
  const mutationKey = ['register']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, { data: UserRegistrationDto }> = (props) => {
    const { data } = props ?? {}

    return register(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = UserRegistrationDto
export type RegisterMutationError = unknown

export const useRegister = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext> => {
  const mutationOptions = getRegisterMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const profile = (signal?: AbortSignal) => {
  return customAxiosInstance<UserResponseDto>({ url: `/api/authentication/profile`, method: 'GET', signal })
}

export const getProfileInfiniteQueryKey = () => {
  return ['infinite', `/api/authentication/profile`] as const
}

export const getProfileQueryKey = () => {
  return [`/api/authentication/profile`] as const
}

export const getProfileInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof profile>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProfileInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileInfiniteQueryError = unknown

export function useProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof profile>>, TError, Awaited<ReturnType<typeof profile>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof profile>>, TError, Awaited<ReturnType<typeof profile>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof profile>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getProfileInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getProfileQueryOptions = <TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProfileQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileQueryError = unknown

export function useProfile<TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof profile>>, TError, Awaited<ReturnType<typeof profile>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfile<TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof profile>>, TError, Awaited<ReturnType<typeof profile>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProfile<TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProfile<TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const refresh = (signal?: AbortSignal) => {
  return customAxiosInstance<LoginResponseDto>({ url: `/api/authentication/refresh`, method: 'GET', signal })
}

export const getRefreshInfiniteQueryKey = () => {
  return ['infinite', `/api/authentication/refresh`] as const
}

export const getRefreshQueryKey = () => {
  return [`/api/authentication/refresh`] as const
}

export const getRefreshInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRefreshInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof refresh>>> = ({ signal }) => refresh(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RefreshInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
export type RefreshInfiniteQueryError = unknown

export function useRefreshInfinite<TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof refresh>>, TError, Awaited<ReturnType<typeof refresh>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRefreshInfinite<TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof refresh>>, TError, Awaited<ReturnType<typeof refresh>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRefreshInfinite<TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRefreshInfinite<TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRefreshInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getRefreshQueryOptions = <TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRefreshQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof refresh>>> = ({ signal }) => refresh(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RefreshQueryResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
export type RefreshQueryError = unknown

export function useRefresh<TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof refresh>>, TError, Awaited<ReturnType<typeof refresh>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRefresh<TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof refresh>>, TError, Awaited<ReturnType<typeof refresh>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRefresh<TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRefresh<TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRefreshQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const bootInfo = (signal?: AbortSignal) => {
  return customAxiosInstance<BootInfoDto>({ url: `/api/boot-info`, method: 'GET', signal })
}

export const getBootInfoInfiniteQueryKey = () => {
  return ['infinite', `/api/boot-info`] as const
}

export const getBootInfoQueryKey = () => {
  return [`/api/boot-info`] as const
}

export const getBootInfoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getBootInfoInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bootInfo>>> = ({ signal }) => bootInfo(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof bootInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BootInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof bootInfo>>>
export type BootInfoInfiniteQueryError = unknown

export function useBootInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof bootInfo>>, TError, Awaited<ReturnType<typeof bootInfo>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBootInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof bootInfo>>, TError, Awaited<ReturnType<typeof bootInfo>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBootInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useBootInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getBootInfoInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getBootInfoQueryOptions = <TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getBootInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bootInfo>>> = ({ signal }) => bootInfo(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof bootInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BootInfoQueryResult = NonNullable<Awaited<ReturnType<typeof bootInfo>>>
export type BootInfoQueryError = unknown

export function useBootInfo<TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof bootInfo>>, TError, Awaited<ReturnType<typeof bootInfo>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBootInfo<TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof bootInfo>>, TError, Awaited<ReturnType<typeof bootInfo>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBootInfo<TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useBootInfo<TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getBootInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const addFeed = (feedInputDto: FeedInputDto, signal?: AbortSignal) => {
  return customAxiosInstance<FeedResponseDto>({
    url: `/api/feed`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: feedInputDto,
    signal,
  })
}

export const getAddFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext> => {
  const mutationKey = ['addFeed']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFeed>>, { data: FeedInputDto }> = (props) => {
    const { data } = props ?? {}

    return addFeed(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddFeedMutationResult = NonNullable<Awaited<ReturnType<typeof addFeed>>>
export type AddFeedMutationBody = FeedInputDto
export type AddFeedMutationError = unknown

export const useAddFeed = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext> => {
  const mutationOptions = getAddFeedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getUserFeeds = (signal?: AbortSignal) => {
  return customAxiosInstance<UserFeedResponseDto[]>({ url: `/api/feed`, method: 'GET', signal })
}

export const getGetUserFeedsInfiniteQueryKey = () => {
  return ['infinite', `/api/feed`] as const
}

export const getGetUserFeedsQueryKey = () => {
  return [`/api/feed`] as const
}

export const getGetUserFeedsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserFeedsInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFeeds>>> = ({ signal }) => getUserFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserFeeds>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserFeedsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFeeds>>>
export type GetUserFeedsInfiniteQueryError = unknown

export function useGetUserFeedsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFeeds>>,
          TError,
          Awaited<ReturnType<typeof getUserFeeds>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFeedsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFeeds>>,
          TError,
          Awaited<ReturnType<typeof getUserFeeds>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFeedsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserFeedsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserFeedsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUserFeedsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserFeeds>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserFeedsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFeeds>>> = ({ signal }) => getUserFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserFeeds>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserFeedsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFeeds>>>
export type GetUserFeedsQueryError = unknown

export function useGetUserFeeds<TData = Awaited<ReturnType<typeof getUserFeeds>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFeeds>>,
          TError,
          Awaited<ReturnType<typeof getUserFeeds>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFeeds<TData = Awaited<ReturnType<typeof getUserFeeds>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFeeds>>,
          TError,
          Awaited<ReturnType<typeof getUserFeeds>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFeeds<TData = Awaited<ReturnType<typeof getUserFeeds>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserFeeds<TData = Awaited<ReturnType<typeof getUserFeeds>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserFeedsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const discoverFeed = (params: DiscoverFeedParams, signal?: AbortSignal) => {
  return customAxiosInstance<DiscoverResponseDto>({ url: `/api/feed/discover`, method: 'POST', params, signal })
}

export const getDiscoverFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof discoverFeed>>,
    TError,
    { params: DiscoverFeedParams },
    TContext
  >
}): UseMutationOptions<Awaited<ReturnType<typeof discoverFeed>>, TError, { params: DiscoverFeedParams }, TContext> => {
  const mutationKey = ['discoverFeed']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof discoverFeed>>, { params: DiscoverFeedParams }> = (
    props,
  ) => {
    const { params } = props ?? {}

    return discoverFeed(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type DiscoverFeedMutationResult = NonNullable<Awaited<ReturnType<typeof discoverFeed>>>

export type DiscoverFeedMutationError = unknown

export const useDiscoverFeed = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof discoverFeed>>,
      TError,
      { params: DiscoverFeedParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof discoverFeed>>, TError, { params: DiscoverFeedParams }, TContext> => {
  const mutationOptions = getDiscoverFeedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const importFeeds = (feedInputDto: FeedInputDto[], signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/feed/import`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: feedInputDto,
    signal,
  })
}

export const getImportFeedsMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext> => {
  const mutationKey = ['importFeeds']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof importFeeds>>, { data: FeedInputDto[] }> = (props) => {
    const { data } = props ?? {}

    return importFeeds(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportFeedsMutationResult = NonNullable<Awaited<ReturnType<typeof importFeeds>>>
export type ImportFeedsMutationBody = FeedInputDto[]
export type ImportFeedsMutationError = unknown

export const useImportFeeds = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext> => {
  const mutationOptions = getImportFeedsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getFeedSettings = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<FeedSettingsResponseDto>({ url: `/api/feed/${id}/settings`, method: 'GET', signal })
}

export const getGetFeedSettingsInfiniteQueryKey = (id?: string) => {
  return ['infinite', `/api/feed/${id}/settings`] as const
}

export const getGetFeedSettingsQueryKey = (id?: string) => {
  return [`/api/feed/${id}/settings`] as const
}

export const getGetFeedSettingsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedSettingsInfiniteQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedSettings>>> = ({ signal }) =>
    getFeedSettings(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFeedSettings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeedSettingsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedSettings>>>
export type GetFeedSettingsInfiniteQueryError = unknown

export function useGetFeedSettingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedSettings>>,
          TError,
          Awaited<ReturnType<typeof getFeedSettings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedSettingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedSettings>>,
          TError,
          Awaited<ReturnType<typeof getFeedSettings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedSettingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFeedSettingsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeedSettingsInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFeedSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedSettingsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedSettings>>> = ({ signal }) =>
    getFeedSettings(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeedSettings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeedSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedSettings>>>
export type GetFeedSettingsQueryError = unknown

export function useGetFeedSettings<TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedSettings>>,
          TError,
          Awaited<ReturnType<typeof getFeedSettings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedSettings<TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedSettings>>,
          TError,
          Awaited<ReturnType<typeof getFeedSettings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedSettings<TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFeedSettings<TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeedSettingsQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const updateFeedSettings = (id: string, updateFeedSettingsInputDto: UpdateFeedSettingsInputDto) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/settings`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateFeedSettingsInputDto,
  })
}

export const getUpdateFeedSettingsMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFeedSettings>>,
    TError,
    { id: string; data: UpdateFeedSettingsInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFeedSettings>>,
  TError,
  { id: string; data: UpdateFeedSettingsInputDto },
  TContext
> => {
  const mutationKey = ['updateFeedSettings']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFeedSettings>>,
    { id: string; data: UpdateFeedSettingsInputDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateFeedSettings(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFeedSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateFeedSettings>>>
export type UpdateFeedSettingsMutationBody = UpdateFeedSettingsInputDto
export type UpdateFeedSettingsMutationError = unknown

export const useUpdateFeedSettings = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFeedSettings>>,
      TError,
      { id: string; data: UpdateFeedSettingsInputDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateFeedSettings>>,
  TError,
  { id: string; data: UpdateFeedSettingsInputDto },
  TContext
> => {
  const mutationOptions = getUpdateFeedSettingsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getFeedTags = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<TagResponseDto[]>({ url: `/api/feed/${id}/tags`, method: 'GET', signal })
}

export const getGetFeedTagsInfiniteQueryKey = (id?: string) => {
  return ['infinite', `/api/feed/${id}/tags`] as const
}

export const getGetFeedTagsQueryKey = (id?: string) => {
  return [`/api/feed/${id}/tags`] as const
}

export const getGetFeedTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedTagsInfiniteQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedTags>>> = ({ signal }) => getFeedTags(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFeedTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeedTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedTags>>>
export type GetFeedTagsInfiniteQueryError = unknown

export function useGetFeedTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>, TError = unknown>(
  id: string,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedTags>>,
          TError,
          Awaited<ReturnType<typeof getFeedTags>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>, TError = unknown>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedTags>>,
          TError,
          Awaited<ReturnType<typeof getFeedTags>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFeedTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeedTagsInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFeedTagsQueryOptions = <TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedTagsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedTags>>> = ({ signal }) => getFeedTags(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeedTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeedTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedTags>>>
export type GetFeedTagsQueryError = unknown

export function useGetFeedTags<TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedTags>>,
          TError,
          Awaited<ReturnType<typeof getFeedTags>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedTags<TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeedTags>>,
          TError,
          Awaited<ReturnType<typeof getFeedTags>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeedTags<TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFeedTags<TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeedTagsQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const tagFeed = (id: string, tagFeedInputDto: TagFeedInputDto, signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/tags`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tagFeedInputDto,
    signal,
  })
}

export const getTagFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof tagFeed>>,
  TError,
  { id: string; data: TagFeedInputDto },
  TContext
> => {
  const mutationKey = ['tagFeed']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagFeed>>, { id: string; data: TagFeedInputDto }> = (
    props,
  ) => {
    const { id, data } = props ?? {}

    return tagFeed(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type TagFeedMutationResult = NonNullable<Awaited<ReturnType<typeof tagFeed>>>
export type TagFeedMutationBody = TagFeedInputDto
export type TagFeedMutationError = unknown

export const useTagFeed = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tagFeed>>,
      TError,
      { id: string; data: TagFeedInputDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof tagFeed>>, TError, { id: string; data: TagFeedInputDto }, TContext> => {
  const mutationOptions = getTagFeedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const untagFeed = (id: string, tagFeedInputDto: TagFeedInputDto) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/tags`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: tagFeedInputDto,
  })
}

export const getUntagFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof untagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof untagFeed>>,
  TError,
  { id: string; data: TagFeedInputDto },
  TContext
> => {
  const mutationKey = ['untagFeed']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof untagFeed>>, { id: string; data: TagFeedInputDto }> = (
    props,
  ) => {
    const { id, data } = props ?? {}

    return untagFeed(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UntagFeedMutationResult = NonNullable<Awaited<ReturnType<typeof untagFeed>>>
export type UntagFeedMutationBody = TagFeedInputDto
export type UntagFeedMutationError = unknown

export const useUntagFeed = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof untagFeed>>,
      TError,
      { id: string; data: TagFeedInputDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof untagFeed>>,
  TError,
  { id: string; data: TagFeedInputDto },
  TContext
> => {
  const mutationOptions = getUntagFeedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getTags = (signal?: AbortSignal) => {
  return customAxiosInstance<TagResponseDto[]>({ url: `/api/tag`, method: 'GET', signal })
}

export const getGetTagsInfiniteQueryKey = () => {
  return ['infinite', `/api/tag`] as const
}

export const getGetTagsQueryKey = () => {
  return [`/api/tag`] as const
}

export const getGetTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTagsInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsInfiniteQueryError = unknown

export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getTags>>, TError, Awaited<ReturnType<typeof getTags>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTags>>, TError, Awaited<ReturnType<typeof getTags>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTagsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsQueryError = unknown

export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getTags>>, TError, Awaited<ReturnType<typeof getTags>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTags>>, TError, Awaited<ReturnType<typeof getTags>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTagsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const addTag = (tagInputDto: TagInputDto, signal?: AbortSignal) => {
  return customAxiosInstance<TagResponseDto>({
    url: `/api/tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tagInputDto,
    signal,
  })
}

export const getAddTagMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext> => {
  const mutationKey = ['addTag']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTag>>, { data: TagInputDto }> = (props) => {
    const { data } = props ?? {}

    return addTag(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddTagMutationResult = NonNullable<Awaited<ReturnType<typeof addTag>>>
export type AddTagMutationBody = TagInputDto
export type AddTagMutationError = unknown

export const useAddTag = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext> => {
  const mutationOptions = getAddTagMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const removeTag = (id: string) => {
  return customAxiosInstance<void>({ url: `/api/tag/${id}`, method: 'DELETE' })
}

export const getRemoveTagMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext> => {
  const mutationKey = ['removeTag']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTag>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return removeTag(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type RemoveTagMutationResult = NonNullable<Awaited<ReturnType<typeof removeTag>>>

export type RemoveTagMutationError = unknown

export const useRemoveTag = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext> },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext> => {
  const mutationOptions = getRemoveTagMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getHealthStatus = (signal?: AbortSignal) => {
  return customAxiosInstance<GetHealthStatus200>({ url: `/api/health`, method: 'GET', signal })
}

export const getGetHealthStatusInfiniteQueryKey = () => {
  return ['infinite', `/api/health`] as const
}

export const getGetHealthStatusQueryKey = () => {
  return [`/api/health`] as const
}

export const getGetHealthStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getHealthStatus>>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHealthStatusInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthStatus>>> = ({ signal }) => getHealthStatus(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getHealthStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getHealthStatus>>>
export type GetHealthStatusInfiniteQueryError = GetHealthStatus503

export function useGetHealthStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getHealthStatus>>>,
  TError = GetHealthStatus503,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthStatus>>,
          TError,
          Awaited<ReturnType<typeof getHealthStatus>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getHealthStatus>>>,
  TError = GetHealthStatus503,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthStatus>>,
          TError,
          Awaited<ReturnType<typeof getHealthStatus>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getHealthStatus>>>,
  TError = GetHealthStatus503,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetHealthStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getHealthStatus>>>,
  TError = GetHealthStatus503,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHealthStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetHealthStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealthStatus>>,
  TError = GetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHealthStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthStatus>>> = ({ signal }) => getHealthStatus(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHealthStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getHealthStatus>>>
export type GetHealthStatusQueryError = GetHealthStatus503

export function useGetHealthStatus<TData = Awaited<ReturnType<typeof getHealthStatus>>, TError = GetHealthStatus503>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthStatus>>,
          TError,
          Awaited<ReturnType<typeof getHealthStatus>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthStatus<TData = Awaited<ReturnType<typeof getHealthStatus>>, TError = GetHealthStatus503>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthStatus>>,
          TError,
          Awaited<ReturnType<typeof getHealthStatus>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthStatus<TData = Awaited<ReturnType<typeof getHealthStatus>>, TError = GetHealthStatus503>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetHealthStatus<TData = Awaited<ReturnType<typeof getHealthStatus>>, TError = GetHealthStatus503>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthStatus>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHealthStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const forceFetching = (signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/scheduling/now`, method: 'POST', signal })
}

export const getForceFetchingMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, void, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, void, TContext> => {
  const mutationKey = ['forceFetching']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forceFetching>>, void> = () => {
    return forceFetching()
  }

  return { mutationFn, ...mutationOptions }
}

export type ForceFetchingMutationResult = NonNullable<Awaited<ReturnType<typeof forceFetching>>>

export type ForceFetchingMutationError = unknown

export const useForceFetching = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, void, TContext> },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof forceFetching>>, TError, void, TContext> => {
  const mutationOptions = getForceFetchingMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

export const getUsers = (signal?: AbortSignal) => {
  return customAxiosInstance<UserResponseDto[]>({ url: `/api/user`, method: 'GET', signal })
}

export const getGetUsersInfiniteQueryKey = () => {
  return ['infinite', `/api/user`] as const
}

export const getGetUsersQueryKey = () => {
  return [`/api/user`] as const
}

export const getGetUsersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUsersInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersInfiniteQueryError = unknown

export function useGetUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUsers>>, TError, Awaited<ReturnType<typeof getUsers>>>,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const deleteUser = (userId: unknown) => {
  return customAxiosInstance<void>({ url: `/api/user/${userId}`, method: 'DELETE' })
}

export const getDeleteUserMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { userId: unknown }> = (props) => {
    const { userId } = props ?? {}

    return deleteUser(userId)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>

export type DeleteUserMutationError = unknown

export const useDeleteUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
