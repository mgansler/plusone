/**
 * Generated by orval v6.22.0 ðŸº
 * Do not edit manually.
 * Feeds API
 * OpenAPI spec version: 0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { customAxiosInstance } from './custom-axios'
export type HealthControllerGetHealthStatus503Info = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
} | null

export type HealthControllerGetHealthStatus503Error = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
} | null

export type HealthControllerGetHealthStatus503Details = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
}

export type HealthControllerGetHealthStatus503 = {
  details?: HealthControllerGetHealthStatus503Details
  error?: HealthControllerGetHealthStatus503Error
  info?: HealthControllerGetHealthStatus503Info
  status?: string
}

export type HealthControllerGetHealthStatus200Info = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
} | null

export type HealthControllerGetHealthStatus200Error = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
} | null

export type HealthControllerGetHealthStatus200Details = {
  [key: string]: {
    status?: string
    [key: string]: string
  }
}

export type HealthControllerGetHealthStatus200 = {
  details?: HealthControllerGetHealthStatus200Details
  error?: HealthControllerGetHealthStatus200Error
  info?: HealthControllerGetHealthStatus200Info
  status?: string
}

export type DiscoverFeedParams = {
  /**
   * URL of the website where a feed should be discovered.
   */
  url: string
}

export type FindArticlesParams = {
  /**
   * The string that the article should match.
   */
  s?: string
  /**
   * Should articles appear in chronically ascending or descending order.
   */
  starred?: boolean
  /**
   * Should read articles be included.
   */
  r?: boolean
  /**
   * Should articles appear in chronically ascending or descending order.
   */
  sort?: Sort
  /**
   * The id of the feed this query should be limited to.
   */
  f?: string
  /**
   * Cursor of the last article for pagination.
   */
  cursor?: number
}

export type MarkArticlesReadParams = {
  /**
   * The string that the article should match.
   */
  s?: string
  /**
   * The id of the feed where all articles should be marked as read.
   */
  f?: string
}

export interface TagInputDto {
  name: string
}

export interface TagFeedInputDto {
  tagId: string
}

export interface UpdateFeedSettingsInputDto {
  expandContent: boolean
  includeRead: boolean
  order: Sort
  title?: string
}

export interface FeedSettingsResponseDto {
  expandContent: boolean
  id: string
  includeRead: boolean
  order: Sort
  title: string
}

export interface TagResponseDto {
  id: string
  name: string
}

export interface UserFeedResponseDto {
  expandContent: boolean
  feedId: string
  feedUrl: string
  id: string
  includeRead: boolean
  order: Sort
  originalTitle: string
  tags: TagResponseDto[]
  title?: string
  unreadCount: number
}

export interface FeedResponseDto {
  feedUrl: string
  id: string
  originalTitle: string
  title?: string
}

export interface FeedInputDto {
  feedUrl: string
  title: string
  url?: string
}

export interface DiscoverResponseDto {
  feedUrl: string
  title: string
  url: string
}

export interface BootInfoDto {
  appVersion: string
  pageSize: number
}

export interface UserResponseDto {
  email?: string
  id: string
  isAdmin: boolean
  username: string
}

export interface UserRegistrationDto {
  password: string
  username: string
}

export interface LoginResponseDto {
  access_token: string
  refresh_token: string
}

export interface UserLoginDto {
  password: string
  username: string
}

export interface PaginatedArticleResponseDto {
  content: ArticleResponseDto[]
  lastCursor?: number
  pageSize: number
  totalCount: number
  unreadCount: number
}

export type Sort = (typeof Sort)[keyof typeof Sort]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Sort = {
  desc: 'desc',
  asc: 'asc',
} as const

export interface StarArticleDto {
  starred: boolean
}

export interface ArticleDto {
  content: string
  date: string
  guid: string
  id: string
  link: string
  title: string
}

export interface ArticleResponseDto {
  article: ArticleDto
  cursor: number
  starred: boolean
  unread: boolean
}

export interface ArticleToggleUnreadDto {
  unread: boolean
}

export const markArticlesRead = (params?: MarkArticlesReadParams) => {
  return customAxiosInstance<void>({ url: `/api/article/mark-articles-read`, method: 'POST', params })
}

export const getMarkArticlesReadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markArticlesRead>>,
    TError,
    { params?: MarkArticlesReadParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof markArticlesRead>>,
  TError,
  { params?: MarkArticlesReadParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markArticlesRead>>,
    { params?: MarkArticlesReadParams }
  > = (props) => {
    const { params } = props ?? {}

    return markArticlesRead(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkArticlesReadMutationResult = NonNullable<Awaited<ReturnType<typeof markArticlesRead>>>

export type MarkArticlesReadMutationError = unknown

export const useMarkArticlesRead = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markArticlesRead>>,
    TError,
    { params?: MarkArticlesReadParams },
    TContext
  >
}) => {
  const mutationOptions = getMarkArticlesReadMutationOptions(options)

  return useMutation(mutationOptions)
}

export const toggleUnread = (articleId: string, articleToggleUnreadDto: ArticleToggleUnreadDto) => {
  return customAxiosInstance<ArticleResponseDto>({
    url: `/api/article/${articleId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: articleToggleUnreadDto,
  })
}

export const getToggleUnreadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toggleUnread>>,
    TError,
    { articleId: string; data: ArticleToggleUnreadDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof toggleUnread>>,
  TError,
  { articleId: string; data: ArticleToggleUnreadDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toggleUnread>>,
    { articleId: string; data: ArticleToggleUnreadDto }
  > = (props) => {
    const { articleId, data } = props ?? {}

    return toggleUnread(articleId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type ToggleUnreadMutationResult = NonNullable<Awaited<ReturnType<typeof toggleUnread>>>
export type ToggleUnreadMutationBody = ArticleToggleUnreadDto
export type ToggleUnreadMutationError = unknown

export const useToggleUnread = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toggleUnread>>,
    TError,
    { articleId: string; data: ArticleToggleUnreadDto },
    TContext
  >
}) => {
  const mutationOptions = getToggleUnreadMutationOptions(options)

  return useMutation(mutationOptions)
}

export const starArticle = (articleId: string, starArticleDto: StarArticleDto) => {
  return customAxiosInstance<void>({
    url: `/api/article/${articleId}/star`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: starArticleDto,
  })
}

export const getStarArticleMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof starArticle>>,
    TError,
    { articleId: string; data: StarArticleDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof starArticle>>,
  TError,
  { articleId: string; data: StarArticleDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof starArticle>>,
    { articleId: string; data: StarArticleDto }
  > = (props) => {
    const { articleId, data } = props ?? {}

    return starArticle(articleId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type StarArticleMutationResult = NonNullable<Awaited<ReturnType<typeof starArticle>>>
export type StarArticleMutationBody = StarArticleDto
export type StarArticleMutationError = unknown

export const useStarArticle = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof starArticle>>,
    TError,
    { articleId: string; data: StarArticleDto },
    TContext
  >
}) => {
  const mutationOptions = getStarArticleMutationOptions(options)

  return useMutation(mutationOptions)
}

export const findArticles = (params?: FindArticlesParams, signal?: AbortSignal) => {
  return customAxiosInstance<PaginatedArticleResponseDto>({ url: `/api/article/find`, method: 'GET', params, signal })
}

export const getFindArticlesQueryKey = (params?: FindArticlesParams) => {
  return [`/api/article/find`, ...(params ? [params] : [])] as const
}

export const getFindArticlesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        Awaited<ReturnType<typeof findArticles>>,
        QueryKey,
        FindArticlesParams['cursor']
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindArticlesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticles>>, QueryKey, FindArticlesParams['cursor']> = ({
    signal,
    pageParam,
  }) => findArticles({ ...params, cursor: pageParam || params?.['cursor'] }, signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findArticles>>,
    TError,
    TData,
    Awaited<ReturnType<typeof findArticles>>,
    QueryKey,
    FindArticlesParams['cursor']
  > & { queryKey: QueryKey }
}

export type FindArticlesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findArticles>>>
export type FindArticlesInfiniteQueryError = unknown

export const useFindArticlesInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof findArticles>>, FindArticlesParams['cursor']>,
  TError = unknown,
>(
  params?: FindArticlesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof findArticles>>,
        TError,
        TData,
        Awaited<ReturnType<typeof findArticles>>,
        QueryKey,
        FindArticlesParams['cursor']
      >
    >
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindArticlesInfiniteQueryOptions(params, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFindArticlesQueryOptions = <TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindArticlesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticles>>> = ({ signal }) => findArticles(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findArticles>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type FindArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof findArticles>>>
export type FindArticlesQueryError = unknown

export const useFindArticles = <TData = Awaited<ReturnType<typeof findArticles>>, TError = unknown>(
  params?: FindArticlesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticles>>, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindArticlesQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const recentlyReadArticles = (signal?: AbortSignal) => {
  return customAxiosInstance<ArticleResponseDto[]>({ url: `/api/article/recentlyRead`, method: 'GET', signal })
}

export const getRecentlyReadArticlesQueryKey = () => {
  return [`/api/article/recentlyRead`] as const
}

export const getRecentlyReadArticlesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRecentlyReadArticlesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof recentlyReadArticles>>> = ({ signal }) =>
    recentlyReadArticles(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof recentlyReadArticles>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type RecentlyReadArticlesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof recentlyReadArticles>>>
export type RecentlyReadArticlesInfiniteQueryError = unknown

export const useRecentlyReadArticlesInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof recentlyReadArticles>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRecentlyReadArticlesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getRecentlyReadArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof recentlyReadArticles>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRecentlyReadArticlesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof recentlyReadArticles>>> = ({ signal }) =>
    recentlyReadArticles(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof recentlyReadArticles>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type RecentlyReadArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof recentlyReadArticles>>>
export type RecentlyReadArticlesQueryError = unknown

export const useRecentlyReadArticles = <
  TData = Awaited<ReturnType<typeof recentlyReadArticles>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof recentlyReadArticles>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRecentlyReadArticlesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const login = (userLoginDto: UserLoginDto) => {
  return customAxiosInstance<LoginResponseDto>({
    url: `/api/authentication/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userLoginDto,
  })
}

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: UserLoginDto }> = (props) => {
    const { data } = props ?? {}

    return login(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = UserLoginDto
export type LoginMutationError = unknown

export const useLogin = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: UserLoginDto }, TContext>
}) => {
  const mutationOptions = getLoginMutationOptions(options)

  return useMutation(mutationOptions)
}

export const logout = (signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/authentication/logout`, method: 'GET', signal })
}

export const getLogoutQueryKey = () => {
  return [`/api/authentication/logout`] as const
}

export const getLogoutInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logout>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LogoutInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutInfiniteQueryError = unknown

export const useLogoutInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof logout>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getLogoutInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getLogoutQueryOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = unknown

export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getLogoutQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const register = (userRegistrationDto: UserRegistrationDto) => {
  return customAxiosInstance<UserResponseDto>({
    url: `/api/authentication/register`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userRegistrationDto,
  })
}

export const getRegisterMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, { data: UserRegistrationDto }> = (props) => {
    const { data } = props ?? {}

    return register(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = UserRegistrationDto
export type RegisterMutationError = unknown

export const useRegister = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: UserRegistrationDto }, TContext>
}) => {
  const mutationOptions = getRegisterMutationOptions(options)

  return useMutation(mutationOptions)
}

export const profile = (signal?: AbortSignal) => {
  return customAxiosInstance<UserResponseDto>({ url: `/api/authentication/profile`, method: 'GET', signal })
}

export const getProfileQueryKey = () => {
  return [`/api/authentication/profile`] as const
}

export const getProfileInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof profile>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileInfiniteQueryError = unknown

export const useProfileInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof profile>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getProfileInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getProfileQueryOptions = <TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof profile>>> = ({ signal }) => profile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof profile>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ProfileQueryResult = NonNullable<Awaited<ReturnType<typeof profile>>>
export type ProfileQueryError = unknown

export const useProfile = <TData = Awaited<ReturnType<typeof profile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof profile>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getProfileQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const refresh = (signal?: AbortSignal) => {
  return customAxiosInstance<LoginResponseDto>({ url: `/api/authentication/refresh`, method: 'GET', signal })
}

export const getRefreshQueryKey = () => {
  return [`/api/authentication/refresh`] as const
}

export const getRefreshInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRefreshQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof refresh>>> = ({ signal }) => refresh(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type RefreshInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
export type RefreshInfiniteQueryError = unknown

export const useRefreshInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof refresh>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRefreshInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getRefreshQueryOptions = <TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getRefreshQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof refresh>>> = ({ signal }) => refresh(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type RefreshQueryResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
export type RefreshQueryError = unknown

export const useRefresh = <TData = Awaited<ReturnType<typeof refresh>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof refresh>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRefreshQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const bootInfo = (signal?: AbortSignal) => {
  return customAxiosInstance<BootInfoDto>({ url: `/api/boot-info`, method: 'GET', signal })
}

export const getBootInfoQueryKey = () => {
  return [`/api/boot-info`] as const
}

export const getBootInfoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getBootInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bootInfo>>> = ({ signal }) => bootInfo(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof bootInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type BootInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof bootInfo>>>
export type BootInfoInfiniteQueryError = unknown

export const useBootInfoInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof bootInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getBootInfoInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getBootInfoQueryOptions = <TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getBootInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bootInfo>>> = ({ signal }) => bootInfo(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof bootInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type BootInfoQueryResult = NonNullable<Awaited<ReturnType<typeof bootInfo>>>
export type BootInfoQueryError = unknown

export const useBootInfo = <TData = Awaited<ReturnType<typeof bootInfo>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof bootInfo>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getBootInfoQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const discoverFeed = (params: DiscoverFeedParams) => {
  return customAxiosInstance<DiscoverResponseDto>({ url: `/api/feed/discover`, method: 'POST', params })
}

export const getDiscoverFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof discoverFeed>>,
    TError,
    { params: DiscoverFeedParams },
    TContext
  >
}): UseMutationOptions<Awaited<ReturnType<typeof discoverFeed>>, TError, { params: DiscoverFeedParams }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof discoverFeed>>, { params: DiscoverFeedParams }> = (
    props,
  ) => {
    const { params } = props ?? {}

    return discoverFeed(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type DiscoverFeedMutationResult = NonNullable<Awaited<ReturnType<typeof discoverFeed>>>

export type DiscoverFeedMutationError = unknown

export const useDiscoverFeed = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof discoverFeed>>,
    TError,
    { params: DiscoverFeedParams },
    TContext
  >
}) => {
  const mutationOptions = getDiscoverFeedMutationOptions(options)

  return useMutation(mutationOptions)
}

export const addFeed = (feedInputDto: FeedInputDto) => {
  return customAxiosInstance<FeedResponseDto>({
    url: `/api/feed`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: feedInputDto,
  })
}

export const getAddFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFeed>>, { data: FeedInputDto }> = (props) => {
    const { data } = props ?? {}

    return addFeed(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddFeedMutationResult = NonNullable<Awaited<ReturnType<typeof addFeed>>>
export type AddFeedMutationBody = FeedInputDto
export type AddFeedMutationError = unknown

export const useAddFeed = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addFeed>>, TError, { data: FeedInputDto }, TContext>
}) => {
  const mutationOptions = getAddFeedMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getUserFeeds = (signal?: AbortSignal) => {
  return customAxiosInstance<UserFeedResponseDto[]>({ url: `/api/feed`, method: 'GET', signal })
}

export const getGetUserFeedsQueryKey = () => {
  return [`/api/feed`] as const
}

export const getGetUserFeedsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserFeedsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFeeds>>> = ({ signal }) => getUserFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserFeeds>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetUserFeedsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFeeds>>>
export type GetUserFeedsInfiniteQueryError = unknown

export const useGetUserFeedsInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserFeeds>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserFeedsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUserFeedsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserFeeds>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserFeedsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFeeds>>> = ({ signal }) => getUserFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserFeeds>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetUserFeedsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFeeds>>>
export type GetUserFeedsQueryError = unknown

export const useGetUserFeeds = <TData = Awaited<ReturnType<typeof getUserFeeds>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeeds>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserFeedsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const importFeeds = (feedInputDto: FeedInputDto[]) => {
  return customAxiosInstance<void>({
    url: `/api/feed/import`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: feedInputDto,
  })
}

export const getImportFeedsMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof importFeeds>>, { data: FeedInputDto[] }> = (props) => {
    const { data } = props ?? {}

    return importFeeds(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportFeedsMutationResult = NonNullable<Awaited<ReturnType<typeof importFeeds>>>
export type ImportFeedsMutationBody = FeedInputDto[]
export type ImportFeedsMutationError = unknown

export const useImportFeeds = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof importFeeds>>, TError, { data: FeedInputDto[] }, TContext>
}) => {
  const mutationOptions = getImportFeedsMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getFeeds = (signal?: AbortSignal) => {
  return customAxiosInstance<FeedResponseDto[]>({ url: `/api/feed/all`, method: 'GET', signal })
}

export const getGetFeedsQueryKey = () => {
  return [`/api/feed/all`] as const
}

export const getGetFeedsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeeds>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeeds>>> = ({ signal }) => getFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFeeds>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFeeds>>>
export type GetFeedsInfiniteQueryError = unknown

export const useGetFeedsInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeeds>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeeds>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFeedsQueryOptions = <TData = Awaited<ReturnType<typeof getFeeds>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeeds>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeeds>>> = ({ signal }) => getFeeds(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeeds>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeeds>>>
export type GetFeedsQueryError = unknown

export const useGetFeeds = <TData = Awaited<ReturnType<typeof getFeeds>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeeds>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getFeedSettings = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<FeedSettingsResponseDto>({ url: `/api/feed/${id}/settings`, method: 'GET', signal })
}

export const getGetFeedSettingsQueryKey = (id: string) => {
  return [`/api/feed/${id}/settings`] as const
}

export const getGetFeedSettingsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedSettingsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedSettings>>> = ({ signal }) =>
    getFeedSettings(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFeedSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedSettingsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedSettings>>>
export type GetFeedSettingsInfiniteQueryError = unknown

export const useGetFeedSettingsInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedSettings>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedSettingsInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFeedSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedSettingsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedSettings>>> = ({ signal }) =>
    getFeedSettings(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeedSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedSettings>>>
export type GetFeedSettingsQueryError = unknown

export const useGetFeedSettings = <TData = Awaited<ReturnType<typeof getFeedSettings>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedSettings>>, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedSettingsQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const updateFeedSettings = (id: string, updateFeedSettingsInputDto: UpdateFeedSettingsInputDto) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/settings`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateFeedSettingsInputDto,
  })
}

export const getUpdateFeedSettingsMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFeedSettings>>,
    TError,
    { id: string; data: UpdateFeedSettingsInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFeedSettings>>,
  TError,
  { id: string; data: UpdateFeedSettingsInputDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFeedSettings>>,
    { id: string; data: UpdateFeedSettingsInputDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateFeedSettings(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFeedSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateFeedSettings>>>
export type UpdateFeedSettingsMutationBody = UpdateFeedSettingsInputDto
export type UpdateFeedSettingsMutationError = unknown

export const useUpdateFeedSettings = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFeedSettings>>,
    TError,
    { id: string; data: UpdateFeedSettingsInputDto },
    TContext
  >
}) => {
  const mutationOptions = getUpdateFeedSettingsMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getFeedTags = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<TagResponseDto[]>({ url: `/api/feed/${id}/tags`, method: 'GET', signal })
}

export const getGetFeedTagsQueryKey = (id: string) => {
  return [`/api/feed/${id}/tags`] as const
}

export const getGetFeedTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>,
  TError = unknown,
>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedTagsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedTags>>> = ({ signal }) => getFeedTags(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFeedTags>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedTags>>>
export type GetFeedTagsInfiniteQueryError = unknown

export const useGetFeedTagsInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getFeedTags>>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedTagsInfiniteQueryOptions(id, options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetFeedTagsQueryOptions = <TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeedTagsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeedTags>>> = ({ signal }) => getFeedTags(id, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeedTags>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFeedTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeedTags>>>
export type GetFeedTagsQueryError = unknown

export const useGetFeedTags = <TData = Awaited<ReturnType<typeof getFeedTags>>, TError = unknown>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeedTags>>, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFeedTagsQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const tagFeed = (id: string, tagFeedInputDto: TagFeedInputDto) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/tags`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tagFeedInputDto,
  })
}

export const getTagFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof tagFeed>>,
  TError,
  { id: string; data: TagFeedInputDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagFeed>>, { id: string; data: TagFeedInputDto }> = (
    props,
  ) => {
    const { id, data } = props ?? {}

    return tagFeed(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type TagFeedMutationResult = NonNullable<Awaited<ReturnType<typeof tagFeed>>>
export type TagFeedMutationBody = TagFeedInputDto
export type TagFeedMutationError = unknown

export const useTagFeed = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}) => {
  const mutationOptions = getTagFeedMutationOptions(options)

  return useMutation(mutationOptions)
}

export const untagFeed = (id: string, tagFeedInputDto: TagFeedInputDto) => {
  return customAxiosInstance<void>({
    url: `/api/feed/${id}/tags`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: tagFeedInputDto,
  })
}

export const getUntagFeedMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof untagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof untagFeed>>,
  TError,
  { id: string; data: TagFeedInputDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof untagFeed>>, { id: string; data: TagFeedInputDto }> = (
    props,
  ) => {
    const { id, data } = props ?? {}

    return untagFeed(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UntagFeedMutationResult = NonNullable<Awaited<ReturnType<typeof untagFeed>>>
export type UntagFeedMutationBody = TagFeedInputDto
export type UntagFeedMutationError = unknown

export const useUntagFeed = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof untagFeed>>,
    TError,
    { id: string; data: TagFeedInputDto },
    TContext
  >
}) => {
  const mutationOptions = getUntagFeedMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getTags = (signal?: AbortSignal) => {
  return customAxiosInstance<TagResponseDto[]>({ url: `/api/tag`, method: 'GET', signal })
}

export const getGetTagsQueryKey = () => {
  return [`/api/tag`] as const
}

export const getGetTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTags>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsInfiniteQueryError = unknown

export const useGetTagsInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTagsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTags>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsQueryError = unknown

export const useGetTags = <TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTagsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const addTag = (tagInputDto: TagInputDto) => {
  return customAxiosInstance<TagResponseDto>({
    url: `/api/tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tagInputDto,
  })
}

export const getAddTagMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTag>>, { data: TagInputDto }> = (props) => {
    const { data } = props ?? {}

    return addTag(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddTagMutationResult = NonNullable<Awaited<ReturnType<typeof addTag>>>
export type AddTagMutationBody = TagInputDto
export type AddTagMutationError = unknown

export const useAddTag = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addTag>>, TError, { data: TagInputDto }, TContext>
}) => {
  const mutationOptions = getAddTagMutationOptions(options)

  return useMutation(mutationOptions)
}

export const removeTag = (id: string) => {
  return customAxiosInstance<void>({ url: `/api/tag/${id}`, method: 'DELETE' })
}

export const getRemoveTagMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTag>>, { id: string }> = (props) => {
    const { id } = props ?? {}

    return removeTag(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type RemoveTagMutationResult = NonNullable<Awaited<ReturnType<typeof removeTag>>>

export type RemoveTagMutationError = unknown

export const useRemoveTag = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError, { id: string }, TContext>
}) => {
  const mutationOptions = getRemoveTagMutationOptions(options)

  return useMutation(mutationOptions)
}

export const healthControllerGetHealthStatus = (signal?: AbortSignal) => {
  return customAxiosInstance<HealthControllerGetHealthStatus200>({ url: `/api/health`, method: 'GET', signal })
}

export const getHealthControllerGetHealthStatusQueryKey = () => {
  return [`/api/health`] as const
}

export const getHealthControllerGetHealthStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>>,
  TError = HealthControllerGetHealthStatus503,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthControllerGetHealthStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>> = ({ signal }) =>
    healthControllerGetHealthStatus(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthControllerGetHealthStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type HealthControllerGetHealthStatusInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerGetHealthStatus>>
>
export type HealthControllerGetHealthStatusInfiniteQueryError = HealthControllerGetHealthStatus503

export const useHealthControllerGetHealthStatusInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>>,
  TError = HealthControllerGetHealthStatus503,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getHealthControllerGetHealthStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getHealthControllerGetHealthStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof healthControllerGetHealthStatus>>,
  TError = HealthControllerGetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthControllerGetHealthStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>> = ({ signal }) =>
    healthControllerGetHealthStatus(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthControllerGetHealthStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type HealthControllerGetHealthStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerGetHealthStatus>>
>
export type HealthControllerGetHealthStatusQueryError = HealthControllerGetHealthStatus503

export const useHealthControllerGetHealthStatus = <
  TData = Awaited<ReturnType<typeof healthControllerGetHealthStatus>>,
  TError = HealthControllerGetHealthStatus503,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthControllerGetHealthStatus>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getHealthControllerGetHealthStatusQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const forceFetching = () => {
  return customAxiosInstance<void>({ url: `/api/scheduling/now`, method: 'POST' })
}

export const getForceFetchingMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, {}, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, {}, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forceFetching>>, {}> = () => {
    return forceFetching()
  }

  return { mutationFn, ...mutationOptions }
}

export type ForceFetchingMutationResult = NonNullable<Awaited<ReturnType<typeof forceFetching>>>

export type ForceFetchingMutationError = unknown

export const useForceFetching = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof forceFetching>>, TError, {}, TContext>
}) => {
  const mutationOptions = getForceFetchingMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getUsers = (signal?: AbortSignal) => {
  return customAxiosInstance<UserResponseDto[]>({ url: `/api/user`, method: 'GET', signal })
}

export const getGetUsersQueryKey = () => {
  return [`/api/user`] as const
}

export const getGetUsersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersInfiniteQueryError = unknown

export const useGetUsersInfinite = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUsers>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUsersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown

export const useGetUsers = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUsersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const deleteUser = (userId: unknown) => {
  return customAxiosInstance<void>({ url: `/api/user/${userId}`, method: 'DELETE' })
}

export const getDeleteUserMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { userId: unknown }> = (props) => {
    const { userId } = props ?? {}

    return deleteUser(userId)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>

export type DeleteUserMutationError = unknown

export const useDeleteUser = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: unknown }, TContext>
}) => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions)
}
